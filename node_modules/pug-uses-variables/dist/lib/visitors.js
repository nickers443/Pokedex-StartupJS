"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = visitors;

var _parseAndFindVarsInProgram = _interopRequireDefault(require("../helpers/parseAndFindVarsInProgram"));

var _variables = require("../helpers/variables");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isComponent(input) {
  return /^[A-Z].*$/.test(input);
}

function isSpreadOperator(input) {
  return /^\.{3}[A-z0-9$]+(\.[A-z0-9$]+)*$/.test(input);
}

function doesStringLookLikeObject(string) {
  return /^\s*{/.test(string);
}

function normalizeAttributeValue(token) {
  // `({ ...props })` is a valid code when `...props` is not, so we
  // are making this normalization to avoid syntax errors
  if (isSpreadOperator(token.name)) {
    return "({".concat(token.name, "})");
  } // Just an object (like `{ first: 'one' }`) is not valid string to
  // be parsed by babel, so we need to wrap it by braces


  if (typeof token.val === 'string' && doesStringLookLikeObject(token.val)) {
    return "(".concat(token.val, ")");
  } // Pug can return a boolean variable for attribute value, but babel
  // can parses only strings


  return String(token.val);
}

function visitors(state, token, template) {
  var location = token.loc;
  var source = template.split('\n').slice(location.start.line - 1, location.end.line);

  switch (token.type) {
    case 'outdent':
      {
        state.clearContext(location.end.column);
        break;
      }

    case 'tag':
      {
        if (isComponent(token.val)) {
          var variable = (0, _variables.findVariable)(token.val, location, source);
          state.addVariables(location.start.column, [variable]);
        }

        break;
      }

    case 'attribute':
      {
        var normalizedValue = normalizeAttributeValue(token);
        var usedVariables = (0, _parseAndFindVarsInProgram.default)(normalizedValue).used.map(function (name) {
          var localLine = source.findIndex(function (loc) {
            return loc.indexOf(name) > -1;
          });
          var line = location.start.line + localLine;
          var valueStartsAt = isSpreadOperator(token.name) ? location.start.column : location.start.column + (token.name.length - 1);
          var columnStart = localLine > 0 ? source[localLine].indexOf(name) : valueStartsAt + source[0].substring(valueStartsAt).indexOf(name);
          var columnEnd = columnStart + name.length;
          return (0, _variables.buildVariable)(name, [line, columnStart], [line, columnEnd]);
        });
        state.addVariables(location.start.column, usedVariables);
        break;
      }

    case 'interpolated-code':
    case 'if':
      {
        var _usedVariables = (0, _parseAndFindVarsInProgram.default)(token.val).used.map(function (name) {
          return (0, _variables.findVariable)(name, location, source);
        });

        state.addVariables(location.start.column, _usedVariables);
        break;
      }

    case 'code':
      {
        var variables = (0, _parseAndFindVarsInProgram.default)(token.val);
        state.addToContext(location.start.column, variables.defined);

        var _usedVariables2 = variables.used.map(function (name) {
          return (0, _variables.findVariable)(name, location, source);
        });

        state.addVariables(location.start.column, _usedVariables2);
        break;
      }

    case 'each':
      {
        var defined = [token.val, token.key]; // We need to increase column because 'each' creates own scope and
        // defines variables inside it

        state.addToContext(location.start.column + 1, defined);

        var _usedVariables3 = (0, _parseAndFindVarsInProgram.default)(token.code).used.map(function (name) {
          return (0, _variables.findVariable)(name, location, source);
        });

        state.addVariables(location.start.column, _usedVariables3);
        break;
      }

    default:
      break;
  }
}